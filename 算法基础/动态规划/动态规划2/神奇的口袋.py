"""
有一个神奇的口袋,
总的容积是40，用这个口袋可以变出一
些物品，这些物品的总体积必须是40。
John现在有n(1≤n≤20)个想要得到的物品，每个物品
的体积分别是a，a....n。. John可以从这些物品中选择一
些，如果选出的物体的总体积是40，那么利用这个神奇的口
袋，John就可以得到这些物品。现在的问题是，John有多少
种不同的选择物品的方式。

解题思路
F(C,N): 取前N件凑容积大小为C
递推公式: F(C,N) = F(C,N-1)+F(C-aN,N-1)
边界条件: if (C==0): return 1
        if (C==0 & N<=0): return 0
复杂度: O(n^2)
"""
# 输入物品的数量
n = int(input())
# 输入每个物品的体积
volumes = list(map(int,input().split()))

# 初始化动态规划数组
# dp[i][j]表示从前i个物品中选取一些物品，使得它们的体积之和为j的方案数
dp = [[0 for _ in range(41)] for _ in range(n+1)]
# 边界条件：没有物品可以取时，体积为0的方案数为1，体积不为0的方案数为0
"""
dp
1 0 0 0 0 0
1
1
1
1
"""
dp[0][0] = 1

# 动态规划
for i in range(1, n+1):
    for j in range(41):
        # 如果不取第i个物品
        dp[i][j] = dp[i-1][j]
        # 如果取第i个物品，且剩余的体积足够
        if j >= volumes[i-1]:
            dp[i][j] += dp[i-1][j-volumes[i-1]]

# 输出答案
print(dp[n][40])
