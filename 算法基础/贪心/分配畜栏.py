"""
有n头牛( 1<=n<=50,000)要挤奶。给定每头牛挤奶的时间区间[A,B] (1<=A<=B<=1,000,000 , A,B为整数)。
牛需要呆畜栏里才能挤奶。一个畜栏同一时间只能容纳一头牛。
问至少需要多少个畜栏,才能完成全部挤奶工作,以及每头牛都
放哪个畜栏里
去同一个畜栏的两头:牛,它们挤奶时间区间哪怕只在端点重合也
是不可以的。

所有奶牛都必须挤奶。到了一一个奶牛的挤奶开始时间,就必须为这个奶
牛找畜栏。因此按照奶牛的开始时间逐个处理它们,是必然的。
S(x)表示奶牛x的开始时间。E(x)表示x的结束时间。对于E(x), x可以是奶牛
,也可以是畜栏。 畜栏的结束时间,就是正在其里面挤奶的奶牛的结束
时间。同一个畜栏的结束时间是不断在变的。

解法：
1)把所有奶牛按开始时间从小到大排序。
2)为第一头奶牛分配一个畜栏。
3)依次处理后面每头奶牛i。处理i时,考虑已分配畜栏中,结束时间最
早的畜栏x。
若E(x) < S(i),则不用分配新畜栏,河进入x,并修改E(x)为E(i)
若E(x) >= S(i) ,则分配新畜栏y,记E(y) = E(i)
eduPlayer v0.37.0 
直到所有奶牛处理结束
显示统计信息
需要用优先队列存放已经分配的畜栏,并使得结束时间最早的畜栏始终
位于队列头部。
Input：
5
20 50
30 60
70 90
10 20
30 50
Output：

"""
# 第1行输入n头牛
n = int(input())
# 第二行到第n+1行是牛的开始到结束时间
# 牛群是一个列表，每个牛也是一个列表，有三个元素：编号(从0开始)，开始时间，结束时间
niu = [[i] for i in range(n)]
for i in range(n):
    start, end = map(int, input().split())
    niu[i].append(start)
    niu[i].append(end)

# 排序，但是生成个副本，保留原列表
niu2 = sorted(niu, key=lambda x: x[1])

# 导入优先权队列
import heapq
# 畜栏，至少有一头牛，至少有一个畜栏(列表)，记录的是下次空闲时间和编号，编号从0开始
corral = [[0, 0]]
j = 1
# 对于每头牛
for i in niu2:
    # 如果牛的开始时间大于堆顶(最小元素或者说最小的结束时间):
    if i[1] > corral[0][0]:
        node = heapq.heappop(corral)
        # 存入结束时间和编号
        heapq.heappush(corral, [i[2], node[1]])
        # 原牛列表存入畜栏编号
        niu[i[0]].append(node[1])
    else:  # 不然分配新的畜栏
        heapq.heappush(corral, [i[2], j])
        # 原牛列表存入畜栏编号
        niu[i[0]].append(j)
        j += 1

print(len(corral))
# 打印每头牛被分配到的畜栏编号
for cow in niu:
    print(cow[3], end=' ')

