### 杭电15年笔试真题汇总

1. 给定一个字符串,计算字符串中数值的个数并求和。其中还包含了负号，若紧跟负号的是一个数值，则表示这是一个负数，若后面跟着的不是数字，则不表示什么。输入：一个字符串输出：数值个数数值和列子 
输入：312ab-2—9–a 
输出：3 301 
多年不写代码，现在写个这么简单的判断都如此笨拙，而且代码丑陋无比，后来的考杭电的大佬，如果有更好的思路，麻烦在下面贴出你的代码，以便大家学习 

思路： 
1. 对这个字符串进行暴力遍历。 
2. 如果遍历过程中遇到“-”号，并且”-“号后面就是数字的话，那么就进入一个死循环，并且更新暴力指针，直到把这个负数完整的取出来，解除死循环，继续暴力该字符串。 
3. 如果遇到数字的话，那么就可以肯定他一定是正数，负数的话一定会走第二步，走不到这一步的。进入死循环，更新暴力指针，把这个字符串存储到一个临时数组中，然后使用atoi函数，将这个字符串转换成数字即可。 
4. 我们把2,3两步中取出来的字符串放入到一个sum数组当中。 
5. 把sum数组中取出来的所有正数或者负数，进行累加求和。我们就可以得到最终的结果。 

---

2. 给定一个数字矩阵，如果上下左右数值相同，则表示是一个连通的区域。求矩阵中连通块的数量。输入：先是矩阵的行数和列数接着是矩阵输出：连通块的数量 
例子 
5 6 
4 4 4 4 4 4 
4 2 3 3 1 4 
4 2 2 3 1 4 
4 2 3 3 1 4 
4 4 4 4 4 4 
输出 
4 
说明所有4能连起来，还有2 3 1，都有各自能连通块。

思路： 
这道题有很明显的BFS倾向，然后我就用BFS做了。。。 
1. 设置一个判断模块儿，（BFS最恶心的一个地方就是，它乱走，很有可能就会越界，或者直接走你走过的地方。）所以你需要设置一个判断模块儿，看自己是否走出地图的范围了，或者看一下你是不是走的是之前已经走过的路。而且这道题有个特点就是，只有两个字符相同了，你才能到达，他们之间才有路。 
2. 宽搜模块儿，实现一个点到它上下左右四个位置的遍历，对每一个位置进行判断。若判断模块儿为真，就加入队列，若为假，就说明该位置不可用。 
宽搜流程：
先把第一个点放入队列（这个点是我们宽搜的起点），并标记为访问过了。
进入一个循环，条件为队列不空。这个是告诉我们只要你还有走路的可能，你就要一直走下去。
每次循环取出队头，然后出队，标记为访问过。
对取出的队头进行上下左右四个位置的尝试，每次尝试都判断一下是否能够满足判断模块儿，满足就入队，不满足就continue
3. 我们要判断的是连通性。那我们要知道一点，需要一次BFS就能访问到所有节点的图一定是一个连通。需要两次才能访问完的一定是两个连通。我们利用这个性质写一个判断。如果BFS后还有没被访问过的点，那么连通的数量就+1.

