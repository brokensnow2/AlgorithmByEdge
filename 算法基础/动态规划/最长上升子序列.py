"""
问题描述
一个数的序列ai，当a1 < a2 < ... < as的时候，我们称这个
序列是.上升的。对于给定的一个序列(a，a2， ..，an)， 我们可
以得到一些上升的子序列(ai1，ai2, ..，aik),
这里1 <= i1 < i2 <...< iK <= n。比如，对于序列(1，7，3，5，9，4，8),
有它的一些上升子序列，如(1，7)， (3， 4，8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).
你的任务，就是对于给定的序列，求出最长上升子序列的长度。

1.找子问题.
“求以ak(k=1，2，3...N)为终点的最长上升子序列的
长度”
一个上升子序列中最右边的那个数，称为该子序列的
“终点”
虽然这个子问题和原问题形式上并不完全一样，但
是只要这N个子问题都解决了，那么这N个子问题的解中，
最大的那个就是整个问题的解

2. 确定状态:
子问题只和一个变量--数字的位置相关。因此序列中数的位置k就是“状态”，
而状态k对应的值,， 就是以ak为“终点”的最长上升子序列的长度。
状态一共有N个。

3.找出状态转移方程:
maxLen(k) 表示以ak做为“终点”的
最长上升子序列的长度那么:
初始状态: maxLen (1) = 1
maxLen(k)=max{maxLen(i):1<=i<k且a;<a,且k≠1}+1
若找不到这样的i,则maxLen(k) = 1
maxLen(k)的值，就是在ak左边，“终点”数值小于ak，且长度
最大的那个上升子序列的长度再加1。因为ap左边任何“终点”小于
a的子序列，加上ap后就能形成一个更长的上升子序列。

"""
def longest_increasing_subsequence(seq):
    # 初始化dp数组
    dp = [1] * len(seq)
    # 遍历序列中的每个元素
    for i in range(len(seq)):
        # 对于每个元素，检查它之前的所有元素
        for j in range(i):
            # 如果前面的元素小于当前元素，并且以前面的元素为终点的最长上升子序列的长度+1大于当前的dp[i]
            if seq[j] < seq[i] and dp[j] + 1 > dp[i]:
                # 更新dp[i]
                dp[i] = dp[j] + 1
    # 返回dp数组中的最大值，即最长上升子序列的长度
    return max(dp)

# 测试
seq = list(map(int, input().split()))
print(longest_increasing_subsequence(seq))
