/**
 * 解法：循环节
 * 代码超时可能是因为`N`的值非常大，而代码复杂度是`O(N)`。对于这种问题，我们可以寻找一种叫做"循环节"的现象。
 * 在这个问题中，`f(n)`是由`f(n-1)`和`f(n-2)`决定的，而`f(n-1)`和`f(n-2)`的值都是模7得到的，
 * 所以它们的值只能在0到6之间。这意味着`f(n)`的值也只能在0到6之间。
 * 因此，当`n`增大时，`f(n)`的值必然会开始重复，形成一个循环节。
 * 可以修改你的代码，使其在计算`f(n)`的过程中检测到循环节的出现。
 * 一旦检测到循环节，你就可以通过`N`除以循环节长度的余数来快速找到`f(N)`的值，
 * 从而避免了对大量的`N`进行迭代计算。
*/
#include <iostream>  // 引入输入输出流库
#include <vector>    // 引入向量库

using namespace std; // 使用标准命名空间

int main()           // 主函数
{
    int A, B, N;     // 定义输入的三个整数变量
    while (cin >> A >> B >> N && (A || B || N)) // 当输入的三个数不全为0时，进入循环
    {
        vector<int> f(3, 1);  // 定义一个向量f，并初始化前三个元素为1
        int i = 2;            // 定义一个索引变量i，并初始化为2
        while (true)          // 进入无限循环
        {
            f.push_back((A * f[i] + B * f[i - 1]) % 7); // 计算f(n)的值，并将其添加到向量f中
            if (f[i] == 1 && f[i - 1] == 1 && i > 2) // 如果连续两个f(n)的值都为1，那么就找到了循环节，跳出循环
                break;
            i++;              // 索引i自增
        }
        cout << f[N % (i-2)] << endl; // 输出f(N)的值，N除以循环节长度的余数为索引
    }
    return 0;  // 主函数返回0，表示程序正常结束
}

