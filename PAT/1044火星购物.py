"""
在火星购物是一种完全不同的体验。火星人用钻石链支付。每颗钻石都有一个价值（以玛氏美元M$为单位）。付款时，链条在任何位置都只能切割一次，
一些钻石会被逐一从链条上取下。钻石一旦从链子上脱落，就无法收回。例如，如果我们有一个价值M$3、2、1、5、4、6、8、7的8颗钻石链，
我们必须支付M$15。我们可能有三种选择：
切割4到6之间的链，并从位置1到5取下钻石（值为3+2+1+5+4=15）。
在5之前或6之后切割，从4到6的位置取下钻石（值为5+4+6=15）。
在8之前切割，从7到8的位置取下钻石（值为8+7=15）。
现在，考虑到钻石价值链和客户必须支付的金额，您应该列出客户的所有支付选项。
如果无法支付确切的金额，您必须建议损失最小的解决方案。
输入规范：
每个输入文件包含一个测试用例。对于每种情况，第一行包含2个数字：N（≤10^5)，链上的钻石总数，以及M（≤10^8)，客户必须支付的金额。
那么下一行包含N个正数D1...DN (Di≤10^3)
对于所有Di(i=1，…，N)，它们是钻石的价值。一行中的所有数字都用空格隔开。
输出规格：
对于每个测试用例，在每对i≤j的行中打印i-j，使得Di+…+Dj=M。注意，如果有多个解决方案，则必须按i的递增顺序打印所有解决方案。
如果没有解，则输出i≤j对的i-j，使得Di+…+Dj>M，其中（Di+…+Dj−M）最小化。同样，所有的解决方案都必须按i的递增顺序打印。
保证钻石的总价值足以支付一定的数额。
样本输入1：
16 15
3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13
样本输出1：
1-5
4-6
7-8
11-11
样本输入2：
5 13
2 4 5 7 9
样本输出2：
2-4
4-5
"""

"""
思路：从位置1开始找到刚>=M的解，再从位置2开始找到刚>=M的解，比较谁小更新min，如果相同加到results列表中。
在判断右侧的临界位置时使用了技巧。
"""
# N（≤10^5)，链上的钻石总数，以及M（≤10^8)，客户必须支付的金额。
N, M = map(int,input().split())  # 读取钻石链的长度和客户需要支付的金额
# 钻石链
chain = list(map(int,input().split()))  # 读取钻石链
min = float('inf')  # 初始化最小总价值为无穷大
length = len(chain)  # 获取钻石链的长度
results = []  # 初始化结果列表

left, right = 0, 0  # 初始化两个指针，都指向链的开始
sum = 0  # 初始化子链的总价值为0

# 当右指针没有超过链的长度时，继续循环
while right < length:
    # 将右指针指向的钻石的价值加到子链的总价值中
    sum += chain[right]
    # 如果子链的总价值大于或等于客户需要支付的金额，那么就尝试移动左指针
    while sum >= M:
        # 如果子链的总价值等于当前最小的总价值，那么将这个子链的开始和结束位置添加到结果中
        if sum == min:
            results.append((left+1, right+1))
        # 如果子链的总价值小于当前最小的总价值，那么清空结果，并将这个子链的开始和结束位置添加到结果中，同时更新最小总价值
        elif sum < min:
            results = [(left+1, right+1)]
            min = sum
        # 将左指针指向的钻石的价值从子链的总价值中减去，此时的sum肯定小于刚刚的，之前left的最优解找到了，所以left右移 
        """
        right只可能右移：
        此时的sum（left+1...right）肯定小于刚刚(left...right)的；
        right不可能左移，因为(left...right-1)还不满足>M的条件，到了（left...right)才满足条件，
        （left+1...right-1）更不满足条件，所以right只可能右移
        """
        sum -= chain[left]
        # 移动左指针
        left += 1
    # 移动右指针
    right += 1

# 打印所有结果中的子链的开始和结束位置
for left, right in results:
    print(f"{left}-{right}")

