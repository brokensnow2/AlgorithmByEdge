/*
分解质因数法：先把这几个数分解质因数，
再把它们一切公有的质因数和其中几个数公有的质因数
以及每个数的独有的质因数全部连乘起来，所得的积就是它们的最小公倍数。
例如，求 [12,18,20,60] 的最小公倍数，
因为12=2×2×3，18=2×3×3，20=2×2×5，60=2×2×3×5，
其中四个数的公有的质因数为2，三个数的公有的质因数为2与3，
两个数的公有的质因数为5，有个数独有的质因数为3。
所以，[12,18,20,60]的最小公倍数=2×2×3×3×5=180。

公式法：由于两个数的乘积等于这两个数的最大公约数与最小公倍数的积，
即(a,b)×[a,b]=a×b。所以，求两个数的最小公倍数，
就可以先求出它们的最大公约数，然后用上述公式求出它们的最小公倍数。
例如，求 [18,20] 的最小公倍数，
即得 [18,20]=18×20÷(18,20)=18×20÷2=180。
求几个自然数的最小公倍数，可以先求出其中两个数的最小公倍数，
再求这个最小公倍数与第三个数的最小公倍数，依次求下去，直到最后一个为止。
最后所得的那个最小公倍数，就是所求的几个数的最小公倍数。
*/

#include <iostream>
#include <vector>

using namespace std;

// 计算最大公约数
/**
使用欧几里得算法（也称为辗转相除法）
来计算两个数的最大公约数（Greatest Common Divisor，GCD）。
欧几里得算法是一种非常古老的算法，它的原理是基于以下的定理：
两个整数的最大公约数等于其中较小的那个数和两数的差的最大公约数。
https://oi-wiki.org/math/number-theory/gcd/
*/

// a > b; 不然下次调用时a,b互换
int gcd(int a, int b) {
    return b == 0 ? a : gcd(b, a % b); //a % b就是a和b的差的绝对值。
}

// 计算最小公倍数
int lcm(int a, int b) {
    return a * b / gcd(a, b);
}

int main() {
    int t;
    while (cin >> t) {
        vector<int> nums(t);
        for (int i = 0; i < t; i++) {
            cin >> nums[i];
        }
        int res = nums[0];
        for (int i = 1; i < t; i++) {
            res = lcm(res, nums[i]);
        }
        cout << res << endl;
    }
    return 0;
}
