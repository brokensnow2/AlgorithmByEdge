/**
 * 问题描述
一排有很多灯。他们一开始都是关闭的。对这些灯进行一系列操作。
在第i次操作中，编号为i倍数的灯改变条件（开到关，关到开）。
 
输入项
每个测试用例在一行中只包含一个数字n(0<n<=10^5)。
 
输出结果
输出无穷大操作后第n个灯的状态（0-关，1-开）。
 
样本输入
1
5
 
示例输出
1
0
考虑第二个测试案例：
初始条件：0 0 0 0 0 0...
第一次操作后：1 1 1 1 1...
第二次操作后：1 0 1 0 1...
第三次操作后：1 0 0 0 1...
第四次操作后：1 0 0 1 1...
第五次操作后：1 0 0 1 0...
后面的操作不能再改变第五盏灯的状况。所以答案是0。
 * 
*/

/**
 * 每个因子都会使灯的状态从开变为关，或者从关变为开。
 * 这意味着，如果一个灯的编号有偶数个因子，那么经过无穷多次操作后，
 * 这个灯最终会关闭；如果一个灯的编号有奇数个因子，那么这个灯最终会开启。
 * 大部分的正整数都有偶数个因子。例如，6有四个因子：1、2、3和6。
 * 这是因为因子通常是成对出现的，例如，2和3都是6的因子，因为2×3=6。
 * 然而，完全平方数是一个例外，因为它们的平方根是一个重复的因子。
 * 例如，9是一个完全平方数，它有三个因子：1、3和9。
 * 因此，完全平方数是唯一具有奇数个因子的正整数。
 * 
*/
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;

int main()
{
    int n;
    while (cin >> n)
    {
        int m = (int)sqrt(n);
		if (m * m == n)
        	printf("1\n");
        else
        	printf("0\n");
    }
}