"""
Michael喜欢滑雪这并不奇怪，因为滑雪的确很刺激。
可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，
你不得不再次走上坡或者等待升降机来载你。
Michael想知道一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字
代表点的高度。下面是一个例子
1  2  3  4  5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子
中，一条可滑行的滑坡为24-17-16-1。 当然25-24-23-...-3-2-1更长。 事实上，这是最
长的一条。输入输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，
每行有C个整数。代表高度h.0<=h<=10000。输出输出最长区域的长度。
输入：
输入的第一行表示区域的行数R和列数C
(1 <= R,C<= 100)。 下面是R行，每行有C个整数，
代表高度h，0<=h<=10000。
输出：
输出最长区域的长度。
样例输入
5 5
1  2  3  4  5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9 
样例输出
25

"""

"""
解题思路
L(i,j)表示从点(i,j)出发的最长滑行长度。
一个点(i,j),如果周围没有比它低的点，L(i,j)= 1
否则
递推公式: L(i,j) 等于(i,j)周围四个点中,比(i,j)低，且L值最大的那个点
的L值，再加1
复杂度: O(n^2)

解法1) “人人为我”式递推

L(i,j)表示从点(ij)出发的最长滑行长度。
一个点(i,j), 如果周围没有比它低的点，L(i,j)= 1
将所有点按高度从小到大排序。每个点的L值都初始化为1
从小到大遍历所有的点。经过一个点(i,j)时，用递推公式求L(,j)

"""
rows, columns = map(int,input().split())
field = [[] for _ in range(rows)]
L = []
for i in range(rows):
    col = list(map(int,input().split()))
    for j in range(columns):
        # 元组：（值，行下标，列下标）
        L.append((col[j],i,j))
        # 二维列表(DP矩阵),存的列表：(值(可以不要)，最长滑行长度)
        field[i].append([col[j],1])
L.sort()

for i in range(len(L)):
    # 如果大于下方的点
    if L[i][1]+1 < rows and L[i][0] > field[L[i][1]+1][L[i][2]][0]:
        field[L[i][1]][L[i][2]][1] = max(field[L[i][1]][L[i][2]][1],field[L[i][1]+1][L[i][2]][1]+1)
    # 如果大于上方的点
    if L[i][0] > field[L[i][1]-1][L[i][2]][0] and L[i][1] > 0:
        field[L[i][1]][L[i][2]][1] = max(field[L[i][1]][L[i][2]][1],field[L[i][1]-1][L[i][2]][1]+1)
    # >左侧
    if L[i][2] > 0 and L[i][0] > field[L[i][1]][L[i][2]-1][0]:
        field[L[i][1]][L[i][2]][1] = max(field[L[i][1]][L[i][2]][1],field[L[i][1]][L[i][2]-1][1]+1)
    # 右侧
    if L[i][2]+1 < columns and L[i][0] > field[L[i][1]][L[i][2]+1][0]:
        field[L[i][1]][L[i][2]][1] = max(field[L[i][1]][L[i][2]][1],field[L[i][1]][L[i][2]+1][1]+1)

#首先使用max()函数和lambda函数来找到每个子列表中第二个元素最大的元素，然后再使用max()函数和lambda函数来找到这些元素中最大的元素
max_element = max(max(field, key=lambda x: max(x, key=lambda y: y[1])))
print(max_element[1])